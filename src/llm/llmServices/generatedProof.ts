import { invariantFailed } from "../../utils/throwErrors";
import { ConfigurationError } from "../llmServiceErrors";
import { ProofGenerationContext } from "../proofGenerationContext";
import { UserModelParams } from "../userModelParams";

import { GeneratedRawContentItem } from "./commonStructures/generatedRawContent";
import { ProofGenerationMetadataHolder } from "./commonStructures/proofGenerationMetadata";
import { ProofVersion } from "./commonStructures/proofVersion";
import { LLMService, LLMServiceImpl } from "./llmService";
import { LLMServiceInternal } from "./llmServiceInternal";
import { ModelParams } from "./modelParams";
import { buildProofFixChat } from "./utils/chatFactory";

/**
 * Facade type for the `GeneratedProofImpl<ResolvedModelParams, GeneratedProofType, LLMServiceInternalType>` type.
 *
 * Most often, the proper typing of `GeneratedProofImpl.modelParams` is not required,
 * while the proper typing of the parent `LLMServiceImpl`, returning `GeneratedProofImpl`-s and `GeneratedProofImpl.llmServiceInternal`
 * is required inside implementation only.
 * Thus, outside of the internal implementation, this class will most likely be parameterized with base classes and any-s.
 */

export type GeneratedProof = GeneratedProofImpl<
    ModelParams,
    LLMService<UserModelParams, ModelParams>,
    GeneratedProof,
    any
>;
/**
 * This class represents a proof generated by `LLMServiceImpl`.
 * It stores all the meta information of its generation.
 *
 * Moreover, it might support multiround generation: fixing, shortening, etc.
 * For this, a new version of this proof could be generated via `LLMServiceInternal.generateFromChat`.
 *
 * Multiround-generation parameters are specified at `ModelParams.multiroundProfile`.
 *
 * Same to `LLMServiceImpl`, multiround-generation methods perform errors handling and logging (in the same way).
 * Same to `LLMServiceImpl`, these methods could be overriden to change the behaviour (of the multiround generation).
 *
 * Finally, `GeneratedProofImpl` keeps the previous proof versions (but not the future ones).
 */
export abstract class GeneratedProofImpl<
    ResolvedModelParams extends ModelParams,
    LLMServiceType extends LLMServiceImpl<
        UserModelParams,
        ResolvedModelParams,
        LLMServiceType,
        GeneratedProofType,
        LLMServiceInternalType
    >,
    GeneratedProofType extends GeneratedProofImpl<
        ResolvedModelParams,
        LLMServiceType,
        GeneratedProofType,
        LLMServiceInternalType
    >,
    LLMServiceInternalType extends LLMServiceInternal<
        ResolvedModelParams,
        LLMServiceType,
        GeneratedProofType,
        LLMServiceInternalType
    >,
> {
    /**
     * An accessor for `ModelParams.multiroundProfile.maxRoundsNumber`.
     */
    readonly maxRoundsNumber: number;

    /**
     * Previous proof versions of the current `GeneratedProofImpl` (including the latest one).
     * Only the last one (i.e. the latest) is allowed to have an incomplete `ProofVersion`.
     *
     * When this `GeneratedProofImpl` is generated in a new round (for example, `fixProof` is called),
     * the `proofVersions` won't track the results (newer proof versions).
     * Completely new `GeneratedProofImpl` objects will be returned,
     * having longer `proofVersions` stored inside.
     */
    readonly proofVersions: ProofVersion[];

    /**
     * Creates an instance of `GeneratedProofImpl`.
     * Should be called only by `LLMServiceImpl`, `LLMServiceInternal` or `GeneratedProofImpl` itself.
     *
     * This constructor is capable of extracting the actual proof (its block of code)
     * from the input `proof` in case it is contaminated with plain text or any other surrounding symbols.
     * Namely, it extracts the block between `Proof.` and `Qed.` if they are present;
     * otherwise, takes the whole `proof`.
     */
    constructor(
        rawProof: GeneratedRawContentItem,
        readonly proofGenerationContext: ProofGenerationContext,
        readonly modelParams: ResolvedModelParams,
        protected readonly llmServiceInternal: LLMServiceInternalType,
        previousProofVersions: ProofVersion[] = []
    ) {
        // Make a copy of the previous proof versions
        this.proofVersions = [...previousProofVersions];

        // Save newly generated `proof`
        this.proofVersions.push({
            proof: GeneratedProofImpl.removeProofQedIfNeeded(rawProof.content),
            rawProof: rawProof,
            diagnostic: undefined,
        });

        this.maxRoundsNumber =
            this.modelParams.multiroundProfile.maxRoundsNumber;
        if (this.maxRoundsNumber < this.proofVersions.length) {
            invariantFailed(
                "`GeneratedProof`",
                "proof cannot be instantiated: max rounds number ",
                `(${this.maxRoundsNumber}) has been already reached`
            );
        }
    }

    /**
     * @returns a proof of the latest version for this `GeneratedProofImpl`.
     */
    get proof(): string {
        return this.lastProofVersion.proof;
    }

    /**
     *
     * @returns a raw proof object as it was generated by the `LLMService`.
     */
    get rawProof(): GeneratedRawContentItem {
        return this.lastProofVersion.rawProof;
    }

    protected get lastProofVersion(): ProofVersion {
        return this.proofVersions[this.proofVersions.length - 1];
    }

    /**
     * Initially generated proofs have version number equal to 1.
     * Each generation round creates `GeneratedProofs` with version = `this.versionNumber() + 1`.
     *
     * @returns version number of this `GeneratedProofImpl`.
     */
    get versionNumber(): number {
        return this.proofVersions.length;
    }

    /**
     * This method doesn't check `ModelParams.multiroundProfile.fixedProofChoices`,
     * because they can be overriden via the function's parameters at the call.
     *
     * @returns whether this `GeneratedProofImpl` is allowed to be fixed at least once.
     */
    canBeFixed(): Boolean {
        return this.nextVersionCanBeGenerated();
    }

    /**
     * @returns whether `maxRoundsNumber` allows to generate a newer version of this proof.
     */
    protected nextVersionCanBeGenerated(): Boolean {
        return this.versionNumber < this.maxRoundsNumber;
    }

    /**
     * Generates new `GeneratedProofImpl`-s as fixes for the latest version of the current one.
     * This method performs errors-handling and logging the same way as `LLMServiceImpl`'s methods do.
     *
     * When this method is called, the `diagnostic` of the latest proof version
     * is overwritten with the `diagnostic` parameter of the call.
     *
     * The default implementation is based on the generation from chat, namely,
     * it calls `LLMServiceInternal.generateFromChatImpl`.
     * If it is not the desired way, `fixProof` should be overriden;
     * however, maintaining all errors-handling and logging invariants.
     * Consider `LLMServiceInternal.logGenerationAndHandleErrors` for help.
     *
     * @param diagnostic the diagnostic received from the compiler.
     * @param choices specifies the number of choices for generation. If not provided, the `params.multiroundProfile.defaultProofFixChoices` value is used.
     * @param metadataHolder if provided, stores metadata about the proof generation process, which can be analyzed later.
     */
    async fixProof(
        diagnostic: string,
        choices: number = this.modelParams.multiroundProfile
            .defaultProofFixChoices,
        metadataHolder: ProofGenerationMetadataHolder | undefined = undefined
    ): Promise<GeneratedProofType[]> {
        return this.llmServiceInternal.generateFromChatWrapped(
            this.modelParams,
            choices,
            metadataHolder,
            () => {
                if (!this.canBeFixed()) {
                    throw new ConfigurationError(
                        `this \`GeneratedProofImpl\` could not be fixed: version ${this.versionNumber} >= max rounds number ${this.maxRoundsNumber}`
                    );
                }
                this.lastProofVersion.diagnostic = diagnostic;
                return buildProofFixChat(
                    this.proofGenerationContext,
                    this.proofVersions,
                    this.modelParams
                );
            },
            (rawProof) =>
                this.llmServiceInternal.constructGeneratedProof(
                    rawProof,
                    this.proofGenerationContext,
                    this.modelParams,
                    this.proofVersions
                )
        );
    }

    private static readonly coqProofBlockPattern =
        /(Proof(?:\s+using(?:\s+\w+)*)?)\.\s*(.*?)\s*(Qed|Defined|Admitted|Abort)\./s;
    private static readonly coqProofBlockStartPattern = [
        "Proof.",
        "Proof using.",
    ];
    private static readonly coqProofBlockEndPattern = [
        "Qed.",
        "Admitted.",
        "Defined.",
        "Abort.",
    ];

    // TODO: move to utils to improve testability
    static removeProofQedIfNeeded(message: string): string {
        const match = this.coqProofBlockPattern.exec(message);
        if (match) {
            return match[2];
        } else {
            if (
                this.coqProofBlockStartPattern.some((pattern) =>
                    message.includes(pattern)
                )
            ) {
                return message.split(this.coqProofBlockStartPattern[0])[1];
            } else if (
                this.coqProofBlockEndPattern.some((pattern) =>
                    message.includes(pattern)
                )
            ) {
                return message.split(this.coqProofBlockEndPattern[0])[0];
            }

            return message;
        }
    }
}
