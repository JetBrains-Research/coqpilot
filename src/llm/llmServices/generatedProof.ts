import { ConfigurationError } from "../llmServiceErrors";
import { ProofGenerationContext } from "../proofGenerationContext";
import { UserModelParams } from "../userModelParams";

import { ErrorsHandlingMode } from "./commonStructures/errorsHandlingMode";
import { ProofVersion } from "./commonStructures/proofVersion";
import { LLMService, LLMServiceImpl } from "./llmService";
import { LLMServiceInternal } from "./llmServiceInternal";
import { ModelParams } from "./modelParams";
import { buildProofFixChat } from "./utils/chatFactory";

/**
 * Facade type for the `GeneratedProofImpl<ResolvedModelParams, GeneratedProofType, LLMServiceInternalType>` type.
 *
 * Most often, the proper typing of `GeneratedProofImpl.modelParams` is not required,
 * while the proper typing of the parent `LLMServiceImpl`, returning `GeneratedProofImpl`-s and `GeneratedProofImpl.llmServiceInternal`
 * is required inside implementation only.
 * Thus, outside of the internal implementation, this class will most likely be parameterized with base classes and any-s.
 */

export type GeneratedProof = GeneratedProofImpl<
    ModelParams,
    LLMService<UserModelParams, ModelParams>,
    GeneratedProof,
    any
>;
/**
 * This class represents a proof generated by `LLMServiceImpl`.
 * It stores all the meta information of its generation.
 *
 * Moreover, it might support multiround generation: fixing, shortening, etc.
 * For this, a new version of this proof could be generated via `LLMServiceInternal.generateFromChat`.
 *
 * Multiround-generation parameters are specified at `ModelParams.multiroundProfile`.
 *
 * Same to `LLMServiceImpl`, multiround-generation methods perform errors handling and logging (in the same way).
 * Same to `LLMServiceImpl`, these methods could be overriden to change the behaviour (of the multiround generation).
 *
 * Finally, `GeneratedProofImpl` keeps the previous proof versions (but not the future ones).
 */
// TODO: support proof metrics access (for example, tokens spent for its generation)

export abstract class GeneratedProofImpl<
    ResolvedModelParams extends ModelParams,
    LLMServiceType extends LLMServiceImpl<
        UserModelParams,
        ResolvedModelParams,
        LLMServiceType,
        GeneratedProofType,
        LLMServiceInternalType
    >,
    GeneratedProofType extends GeneratedProofImpl<
        ResolvedModelParams,
        LLMServiceType,
        GeneratedProofType,
        LLMServiceInternalType
    >,
    LLMServiceInternalType extends LLMServiceInternal<
        ResolvedModelParams,
        LLMServiceType,
        GeneratedProofType,
        LLMServiceInternalType
    >,
> {
    /**
     * An accessor for `ModelParams.multiroundProfile.maxRoundsNumber`.
     */
    readonly maxRoundsNumber: number;

    /**
     * Previous proof versions of the current `GeneratedProofImpl` (including the latest one).
     * Only the last one (i.e. the latest) is allowed to have an incomplete `ProofVersion`.
     *
     * When this `GeneratedProofImpl` is generated in a new round (for example, `fixProof` is called),
     * the `proofVersions` won't track the results (newer proof versions).
     * Completely new `GeneratedProofImpl` objects will be returned,
     * having longer `proofVersions` stored inside.
     */
    readonly proofVersions: ProofVersion[];

    /**
     * Creates an instance of `GeneratedProofImpl`.
     * Should be called only by `LLMServiceImpl`, `LLMServiceInternal` or `GeneratedProofImpl` itself.
     *
     * This constructor is capable of extracting the actual proof (its block of code)
     * from the input `proof` in case it is contaminated with plain text or any other surrounding symbols.
     * Namely, it extracts the block between `Proof.` and `Qed.` if they are present;
     * otherwise, takes the whole `proof`.
     */
    constructor(
        proof: string,
        readonly proofGenerationContext: ProofGenerationContext,
        readonly modelParams: ResolvedModelParams,
        protected readonly llmServiceInternal: LLMServiceInternalType,
        previousProofVersions: ProofVersion[] = []
    ) {
        // Make a copy of the previous proof versions
        this.proofVersions = [...previousProofVersions];

        // Save newly generated `proof`
        this.proofVersions.push({
            proof: this.removeProofQedIfNeeded(proof),
            diagnostic: undefined,
        });

        this.maxRoundsNumber =
            this.modelParams.multiroundProfile.maxRoundsNumber;
        if (this.maxRoundsNumber < this.proofVersions.length) {
            throw Error(
                `proof cannot be instantiated: max rounds number (${this.maxRoundsNumber}) was already reached`
            );
        }
    }

    /**
     * @returns proof of the latest version for this `GeneratedProofImpl`.
     */
    proof(): string {
        return this.lastProofVersion().proof;
    }

    protected lastProofVersion(): ProofVersion {
        return this.proofVersions[this.proofVersions.length - 1];
    }

    /**
     * Initially generated proofs have version number equal to 1.
     * Each generation round creates `GeneratedProofs` with version = `this.versionNumber() + 1`.
     *
     * @returns version number of this `GeneratedProofImpl`.
     */
    versionNumber(): number {
        return this.proofVersions.length;
    }

    /**
     * This method doesn't check `ModelParams.multiroundProfile.fixedProofChoices`,
     * because they can be overriden via the function's parameters at the call.
     *
     * @returns whether this `GeneratedProofImpl` is allowed to be fixed at least once.
     */
    canBeFixed(): Boolean {
        return this.nextVersionCanBeGenerated();
    }

    /**
     * @returns whether `maxRoundsNumber` allows to generate a newer version of this proof.
     */
    protected nextVersionCanBeGenerated(): Boolean {
        return this.versionNumber() < this.maxRoundsNumber;
    }

    /**
     * Generates new `GeneratedProofImpl`-s as fixes for the latest version of the current one.
     * This method performs errors-handling and logging the same way as `LLMServiceImpl`'s methods do.
     *
     * When this method is called, the `diagnostic` of the latest proof version
     * is overwritten with the `diagnostic` parameter of the call.
     *
     * The default implementation is based on the generation from chat, namely,
     * it calls `LLMServiceInternal.generateFromChatImpl`.
     * If it is not the desired way, `fixProof` should be overriden.
     *
     * @param diagnostic diagnostic received from the compiler.
     * @param choices if specified, overrides `ModelParams.multiroundProfile.defaultProofFixChoices`.
     */
    async fixProof(
        diagnostic: string,
        choices: number = this.modelParams.multiroundProfile
            .defaultProofFixChoices,
        errorsHandlingMode: ErrorsHandlingMode = ErrorsHandlingMode.LOG_EVENTS_AND_SWALLOW_ERRORS
    ): Promise<GeneratedProofType[]> {
        return this.llmServiceInternal.generateFromChatWrapped(
            this.modelParams,
            choices,
            errorsHandlingMode,
            () => {
                if (!this.canBeFixed()) {
                    throw new ConfigurationError(
                        `this \`GeneratedProofImpl\` could not be fixed: version ${this.versionNumber()} >= max rounds number ${this.maxRoundsNumber}`
                    );
                }
                this.lastProofVersion().diagnostic = diagnostic;
                return buildProofFixChat(
                    this.proofGenerationContext,
                    this.proofVersions,
                    this.modelParams
                );
            },
            (proof: string) =>
                this.llmServiceInternal.constructGeneratedProof(
                    proof,
                    this.proofGenerationContext,
                    this.modelParams,
                    this.proofVersions
                )
        );
    }

    private readonly coqProofBlockPattern = /Proof\.\s*(.*?)\s*Qed\./s;

    private removeProofQedIfNeeded(message: string): string {
        const match = this.coqProofBlockPattern.exec(message);
        if (match) {
            return match[1];
        } else {
            return message;
        }
    }
}
